## 1.Can you explain the concept of signals in programming? How are they used in Unixlike operating systems?

A signal is a software interrupt sent by the Unix/Linux operating system to a process to inform it that some event or condition has occurred.
Why Are Signals Used?
### 1. Interrupt or Terminate Processes
Examples:
SIGINT – Interrupt (usually Ctrl + C)
SIGTERM – Request process termination (graceful)
SIGKILL – Force kill (cannot be ignored or handled).
### 2. Notify System Events
Example:
SIGCHLD – Sent to a parent when a child process finishes or stops.
### 3. Handle Errors/Exceptions
Examples:
SIGFPE – Arithmetic error (e.g., divide by zero)
SIGSEGV – Invalid memory access (segmentation fault).
### 4. Control Process Execution
Examples:
SIGSTOP – Pause/suspend a process
SIGCONT – Resume a paused process.

## 2.What are software interrupts and hardware interrupts and mention potential issues when dealing with them?

### Software Interrupts
These are interrupts triggered by software/programs.
Example: a program calling a system call (like int 0x80), or sending a signal using kill.
They help a program request services from the OS.
### Hardware Interrupts
These are interrupts generated by hardware devices.
Example: Keyboard key press, mouse movement, timer, network device.
They tell the CPU that hardware needs attention.
### Potential Issues When Dealing With Interrupts
Race conditions – interrupt may occur while shared data is being modified.
Interrupt loss – too many interrupts may cause some to be missed.
Unexpected behavior – interrupts may occur at any time and break normal flow.
Deadlocks – if an interrupt tries to access a locked resource.
Performance overhead – too many interrupts can slow down the system.

# 3.What is synchronous signal and asynchronous signal and how the process can be used for both?
### Synchronous Signal
A synchronous signal happens because of the process’s own action (its own mistake).
It occurs immediately at the point of error.
Example:
SIGFPE → division by zero
SIGSEGV → invalid memory access
The signal is tied to the instruction the process executed
### Asynchronous Signal
An asynchronous signal comes from outside the process.
It can happen at any time, not because of the process’s current instruction.
Examples:
SIGINT → user presses Ctrl+C
SIGTERM → another process sends kill
SIGCHLD → child process ends
How the process uses it?
The process can install a handler to catch the signal and decide what to do (ignore, print message, cleanup, etc.).
| Type             | Triggered By               | Example         | Timing                      |
| ---------------- | -------------------------- | --------------- | --------------------------- |
| **Synchronous**  | Process’s own action/error | SIGFPE, SIGSEGV | At the faulting instruction |
| **Asynchronous** | External events            | SIGINT, SIGTERM | Anytime                     |
## 4.Who is responsible for generating signals?
### The Kernel (Operating System)
Generated automatically when something happens in the system.
Examples:
Division by zero → SIGFPE
Invalid memory access → SIGSEGV
Child process finished → SIGCHLD.
### Other Processes
A process can send a signal to another process.
Using commands or system calls:
kill(pid, SIGTERM)
kill -9 pid
This is used for control or communication.
### The User
Through keyboard actions.
Example:
Pressing Ctrl + C → sends SIGINT
Pressing Ctrl + Z → sends SIGTSTP
The terminal sends the signal on behalf of the user.
## 5.What is signal handler?

### A signal handler is a function that runs when a signal is delivered to a process. Instead of the program stopping or doing the default action, the handler lets you decide what should happen.
EX-Normally, Ctrl + C (SIGINT) stops a program.   

If you set a signal handler, you can make it:
Print a message
Save data
Clean up
Or do anything you want

## 6.Which system call is used to send a signal to the process?

kill(pid, signal_number);

## 7.Write a program to send a signal to itself (same process)?
```
#include <stdio.h>
#include <signal.h>
#include <unistd.h>
void handler(int signo){
printf("signal number=%d\n",signo);
}
int main(){
signal(SIGINT,handler);
printf("Passing a sinal to my self\n");
kill(getpid(),SIGINT);
}
```
## 8.Explain the default action associated with the SIGKILL signal?
```
SIGKILL forcefully kills the process instantly, with no chance to handle or stop it.
Default Action of SIGKILL
Immediate termination of the process
No cleanup (files not closed, memory not freed by the program)
Cannot be caught, blocked, or ignored.
```
## 9.How does a process handle a signal while it is executing in kernel mode?
```
If a signal arrives while the process is in kernel mode, it is not handled immediately. The signal is marked as pending. Once the process returns from kernel mode to user mode, the kernel checks for pending signals. Then the signal is delivered and:
Default action happens or
The signal handler runs (if installed)
No signal handler can handle it.
```
## 10.Describe the behaviour of a process when it receives a SIGSEGV signal?
```
SIGSEGV (Segmentation Fault) happens when a process accesses invalid memory (like dereferencing a bad pointer).
What happens by default?
 The kernel sends SIGSEGV to the process.
 The process is immediately terminated.
 A core dump may be created (if enabled) for debugging.
SIGSEGV means memory error, and the default action is to kill the process (often with a core dump)
```
## 11.What is the role of the sigwait() function in signal handling?
sigwait() waits for a signal and returns it, letting the program handle the signal in a clean, synchronous way.
## Why is it useful?
Makes signal handling controlled and predictable.

Commonly used in multi-threaded programs to let one thread wait for signals.

Avoids the complexity of asynchronous handlers.
## 12. Explain the concept of signal correlation in a distributed environment
When many processes (possibly on different machines) generate different signals/events, we link those signals together to understand that they came from the same cause.

Example

Process 1 sends an error signal

Process 2 sends a timeout signal

Process 3 sends a failure signal

Individually they look separate, but correlation shows they all happened because one service crashed.

## 13 Explain how a process handles a signal while it is in the ready state?
When a process is in the ready state, it is not running, but waiting to be scheduled by the CPU

What Happens?

1️ The signal is marked as pending for that process.

2️ The process does NOT handle the signal immediately (because it’s not running).

3️ When the process gets CPU time and starts running, the kernel checks for pending signals.

4️ The signal is then delivered and handled:

Default action OR Signal handler (if installed).

## 14 What is the role of the sigqueue() function in signal handling?
sigqueue() is a system call used to send a signal to a process, just like kill(), but with an extra advantage.

What makes sigqueue() special?

Unlike kill(), sigqueue() can:
 Send a signal
 
 Send additional data (a value) along with the signal

So the receiving process not only knows which signal arrived, but also gets some extra information.
sigqueue(pid, signal_number, value);

## 15.Describe the interaction between signals and IPC mechanisms in Unix-like systems?
Signals notify events, while IPC transfers data — they work together to coordinate communication between processes.

| **IPC Mechanism**  | **Role of Signals**                                                                  |
| ------------------ | ------------------------------------------------------------------------------------ |
| **Pipes / FIFOs**  | **SIGPIPE** is sent when a process writes to a pipe whose reading end is closed.     |
| **Message Queues** | **SIGIO** can notify a process that new messages are available (async I/O).          |
| **Shared Memory**  | Signals can be used to **notify other processes** that shared data has been updated. |
| **Semaphores**     | Signals can **wake up** or notify processes waiting for synchronization.             |

## 16. Explain how a process can determine the priority of a received signal?
A process determines priority by looking at the signal number — lower numbers mean higher priority, and the OS enforces this order.

Lower signal number = Higher priority

What does the process do?

When a signal comes in, the process can:

Check the signal number (e.g., SIGINT = 2, SIGTERM = 15)

From that number, it knows its priority (because lower = higher)

Signal 2 handled first → higher priority

Signal 15 handled later → lower priority

## 17.What is the role of the sigaltstack() function in signal handling?

What does sigaltstack() do?

It gives the signal handler a backup stack to run on.

Why?

If the normal stack is broken or full, the signal handler might not run.
So sigaltstack() provides another safe place to run the handler.

sigaltstack() lets a signal handler run on a separate stack so the program can handle signals safely even if the main stack has a problem

## 18.  Explain how a process can determine whether a signal was sent by the kernel or another process?
A process can know who sent a signal only if it uses sigaction(), because it provides extra information about the signal.

Inside sigaction(), we get siginfo_t

This structure tells us:

1️ If the signal is from the kernel

si_pid == 0

Means the operating system (kernel) sent the signal
Example: segmentation fault, divide by zero, illegal memory access.

2️ If the signal is from another process.

si_pid > 0

Means another process used kill() or sigqueue() to send the signal The value will be that process's PID.

## 19. Describe the interaction between signals and system calls in Unix-like systems?
Signals can interrupt system calls while they are waiting, causing them to stop early or restart.

EX:  You are waiting for input using read()

If you press Ctrl+C (SIGINT):

The signal interrupts read()
read() ends early instead of waiting

## 20.How does a process handle a signal while it is waiting for a semaphore?
Process waits on semaphore → blocked.

Signal arrives → interrupts the wait.

Semaphore call returns -1 with EINTR.

Signal handler runs.

Process can try semaphore again

## 21.Describe the difference between a signal handler and a signal mask?
Signal handler = what action to perform.

Signal mask = which signals are blocked from interrupting

| Feature     | Signal Handler          | Signal Mask                   |
| ----------- | ----------------------- | ----------------------------- |
| What is it? | A function              | A block list                  |
| Purpose     | Handle the signal       | Block/delay signals           |
| When used?  | When signal arrives     | Before signal arrives         |
| Effect      | Replaces default action | Prevents delivery temporarily |

## 22 How does a process handle a signal while it is in the zombie state?

A zombie is a process that has:

Finished execution But still has an entry in the process table Waiting for the parent to call wait() to collect its exit status It is NOT running anymore.

A zombie process cannot handle signals because it is already dead and not running; only the parent can clean it up using wait().

## 23  What are the advantages and disadvantages of using signals for interprocess communication?
Signals are simple and fast for alerts, but they can’t send much information and may make the program harder to manage.

Advantages (Good Things)
 1️ Easy to use

Just send a signal — no big setup.

2️ Fast notification

The other process gets alerted immediately.

3️ Works even if processes don't share data

They don’t need shared memory, pipes, etc.

 4️ Good for alerts

Like:

process finished

process should stop or continue

Disadvantages (Bad Things)
1️ Can’t send much information

A signal only says “something happened”, nothing more.

 2️ Can interrupt the program

Makes the code harder because the signal can come anytime.

3️ Order is not guaranteed

Signals may arrive out of order.

4️ Not good for big communication

You can’t send large data, only a small notification.

## 24 Explain how a process handles a signal while it is in a sleep state
Signals wake sleeping processes because the kernel interrupts their sleep and delivers the signal.

What happens?

 ### The sleep is interrupted

The process wakes up immediately, even if the sleep time is not finished.

 ### The signal handler runs

If a custom handler is installed, that function executes.

 ### After handling:

Two possibilities:

 A. Sleep ends permanently
The system call returns early with an error (EINTR).

 B. Sleep restarts
If configured to restart (using flags like SA_RESTART), the sleep continues.

## 25 How does a process handle a signal while it is in a critical section?
Signal arrives → Stored as pending → Critical section finishes → Signal is handled.

1️ Signal arrives

The process is busy in a critical section.It cannot be interrupted. So the signal is not handled immediately.

2️ Signal becomes pending

The signal is stored in the pending signal list.It waits there.It is not lost.

3️ Process finishes the critical section

Now signals are unblocked.The process is safe to interrupt.

4️ Signal handler runs

The pending signal is delivered.The signal handler executes.

## 26.






