## 1.Can you explain the concept of signals in programming? How are they used in Unixlike operating systems?

A signal is a software interrupt sent by the Unix/Linux operating system to a process to inform it that some event or condition has occurred.
Why Are Signals Used?
### 1. Interrupt or Terminate Processes
Examples:
SIGINT – Interrupt (usually Ctrl + C)
SIGTERM – Request process termination (graceful)
SIGKILL – Force kill (cannot be ignored or handled).
### 2. Notify System Events
Example:
SIGCHLD – Sent to a parent when a child process finishes or stops.
### 3. Handle Errors/Exceptions
Examples:
SIGFPE – Arithmetic error (e.g., divide by zero)
SIGSEGV – Invalid memory access (segmentation fault).
### 4. Control Process Execution
Examples:
SIGSTOP – Pause/suspend a process
SIGCONT – Resume a paused process.

## 2.What are software interrupts and hardware interrupts and mention potential issues when dealing with them?

### Software Interrupts
These are interrupts triggered by software/programs.
Example: a program calling a system call (like int 0x80), or sending a signal using kill.
They help a program request services from the OS.
### Hardware Interrupts
These are interrupts generated by hardware devices.
Example: Keyboard key press, mouse movement, timer, network device.
They tell the CPU that hardware needs attention.
### Potential Issues When Dealing With Interrupts
Race conditions – interrupt may occur while shared data is being modified.
Interrupt loss – too many interrupts may cause some to be missed.
Unexpected behavior – interrupts may occur at any time and break normal flow.
Deadlocks – if an interrupt tries to access a locked resource.
Performance overhead – too many interrupts can slow down the system.

# 3.What is synchronous signal and asynchronous signal and how the process can be used for both?
### Synchronous Signal
A synchronous signal happens because of the process’s own action (its own mistake).
It occurs immediately at the point of error.
Example:
SIGFPE → division by zero
SIGSEGV → invalid memory access
The signal is tied to the instruction the process executed
### Asynchronous Signal
An asynchronous signal comes from outside the process.
It can happen at any time, not because of the process’s current instruction.
Examples:
SIGINT → user presses Ctrl+C
SIGTERM → another process sends kill
SIGCHLD → child process ends
How the process uses it?
The process can install a handler to catch the signal and decide what to do (ignore, print message, cleanup, etc.).
| Type             | Triggered By               | Example         | Timing                      |
| ---------------- | -------------------------- | --------------- | --------------------------- |
| **Synchronous**  | Process’s own action/error | SIGFPE, SIGSEGV | At the faulting instruction |
| **Asynchronous** | External events            | SIGINT, SIGTERM | Anytime                     |
## 4.Who is responsible for generating signals?
### The Kernel (Operating System)
Generated automatically when something happens in the system.
Examples:
Division by zero → SIGFPE
Invalid memory access → SIGSEGV
Child process finished → SIGCHLD.
### Other Processes
A process can send a signal to another process.
Using commands or system calls:
kill(pid, SIGTERM)
kill -9 pid
This is used for control or communication.
### The User
Through keyboard actions.
Example:
Pressing Ctrl + C → sends SIGINT
Pressing Ctrl + Z → sends SIGTSTP
The terminal sends the signal on behalf of the user.
## 5.What is signal handler?

### A signal handler is a function that runs when a signal is delivered to a process. Instead of the program stopping or doing the default action, the handler lets you decide what should happen.
EX-Normally, Ctrl + C (SIGINT) stops a program.   

If you set a signal handler, you can make it:
Print a message
Save data
Clean up
Or do anything you want

## 6.Which system call is used to send a signal to the process?

kill(pid, signal_number);

## 7.Write a program to send a signal to itself (same process)?
```
#include <stdio.h>
#include <signal.h>
#include <unistd.h>
void handler(int signo){
printf("signal number=%d\n",signo);
}
int main(){
signal(SIGINT,handler);
printf("Passing a sinal to my self\n");
kill(getpid(),SIGINT);
}
```
## 8.Explain the default action associated with the SIGKILL signal?
```
SIGKILL forcefully kills the process instantly, with no chance to handle or stop it.
Default Action of SIGKILL
Immediate termination of the process
No cleanup (files not closed, memory not freed by the program)
Cannot be caught, blocked, or ignored.
```
## 9.How does a process handle a signal while it is executing in kernel mode?
```
If a signal arrives while the process is in kernel mode, it is not handled immediately. The signal is marked as pending. Once the process returns from kernel mode to user mode, the kernel checks for pending signals. Then the signal is delivered and:
Default action happens or
The signal handler runs (if installed)
No signal handler can handle it.
```
## 10.Describe the behaviour of a process when it receives a SIGSEGV signal?
```
SIGSEGV (Segmentation Fault) happens when a process accesses invalid memory (like dereferencing a bad pointer).
What happens by default?
 The kernel sends SIGSEGV to the process.
 The process is immediately terminated.
 A core dump may be created (if enabled) for debugging.
SIGSEGV means memory error, and the default action is to kill the process (often with a core dump)
```
## 11.What is the role of the sigwait() function in signal handling?
sigwait() waits for a signal and returns it, letting the program handle the signal in a clean, synchronous way.
## Why is it useful?
Makes signal handling controlled and predictable.

Commonly used in multi-threaded programs to let one thread wait for signals.

Avoids the complexity of asynchronous handlers.
## 12. Explain the concept of signal correlation in a distributed environment
When many processes (possibly on different machines) generate different signals/events, we link those signals together to understand that they came from the same cause.

Example

Process 1 sends an error signal

Process 2 sends a timeout signal

Process 3 sends a failure signal

Individually they look separate, but correlation shows they all happened because one service crashed.

## 13 Explain how a process handles a signal while it is in the ready state?
When a process is in the ready state, it is not running, but waiting to be scheduled by the CPU

What Happens?

1️ The signal is marked as pending for that process.

2️ The process does NOT handle the signal immediately (because it’s not running).

3️ When the process gets CPU time and starts running, the kernel checks for pending signals.

4️ The signal is then delivered and handled:

Default action OR Signal handler (if installed).

## 14 What is the role of the sigqueue() function in signal handling?
sigqueue() is a system call used to send a signal to a process, just like kill(), but with an extra advantage.

What makes sigqueue() special?

Unlike kill(), sigqueue() can:
 Send a signal
 
 Send additional data (a value) along with the signal

So the receiving process not only knows which signal arrived, but also gets some extra information.
sigqueue(pid, signal_number, value);

## 15.Describe the interaction between signals and IPC mechanisms in Unix-like systems?
Signals notify events, while IPC transfers data — they work together to coordinate communication between processes.

| **IPC Mechanism**  | **Role of Signals**                                                                  |
| ------------------ | ------------------------------------------------------------------------------------ |
| **Pipes / FIFOs**  | **SIGPIPE** is sent when a process writes to a pipe whose reading end is closed.     |
| **Message Queues** | **SIGIO** can notify a process that new messages are available (async I/O).          |
| **Shared Memory**  | Signals can be used to **notify other processes** that shared data has been updated. |
| **Semaphores**     | Signals can **wake up** or notify processes waiting for synchronization.             |

## 16. Explain how a process can determine the priority of a received signal?
A process determines priority by looking at the signal number — lower numbers mean higher priority, and the OS enforces this order.

Lower signal number = Higher priority

What does the process do?

When a signal comes in, the process can:

Check the signal number (e.g., SIGINT = 2, SIGTERM = 15)

From that number, it knows its priority (because lower = higher)

Signal 2 handled first → higher priority

Signal 15 handled later → lower priority

## 17.What is the role of the sigaltstack() function in signal handling?

What does sigaltstack() do?

It gives the signal handler a backup stack to run on.

Why?

If the normal stack is broken or full, the signal handler might not run.
So sigaltstack() provides another safe place to run the handler.

sigaltstack() lets a signal handler run on a separate stack so the program can handle signals safely even if the main stack has a problem

## 18.  Explain how a process can determine whether a signal was sent by the kernel or another process?
A process can know who sent a signal only if it uses sigaction(), because it provides extra information about the signal.

Inside sigaction(), we get siginfo_t

This structure tells us:

1️ If the signal is from the kernel

si_pid == 0

Means the operating system (kernel) sent the signal
Example: segmentation fault, divide by zero, illegal memory access.

2️ If the signal is from another process.

si_pid > 0

Means another process used kill() or sigqueue() to send the signal The value will be that process's PID.

## 19. Describe the interaction between signals and system calls in Unix-like systems?
Signals can interrupt system calls while they are waiting, causing them to stop early or restart.

EX:  You are waiting for input using read()

If you press Ctrl+C (SIGINT):

The signal interrupts read()
read() ends early instead of waiting

## 20.How does a process handle a signal while it is waiting for a semaphore?
Process waits on semaphore → blocked.

Signal arrives → interrupts the wait.

Semaphore call returns -1 with EINTR.

Signal handler runs.

Process can try semaphore again

## 21.Describe the difference between a signal handler and a signal mask?
Signal handler = what action to perform.

Signal mask = which signals are blocked from interrupting

| Feature     | Signal Handler          | Signal Mask                   |
| ----------- | ----------------------- | ----------------------------- |
| What is it? | A function              | A block list                  |
| Purpose     | Handle the signal       | Block/delay signals           |
| When used?  | When signal arrives     | Before signal arrives         |
| Effect      | Replaces default action | Prevents delivery temporarily |

## 22 How does a process handle a signal while it is in the zombie state?

A zombie is a process that has:

Finished execution But still has an entry in the process table Waiting for the parent to call wait() to collect its exit status It is NOT running anymore.

A zombie process cannot handle signals because it is already dead and not running; only the parent can clean it up using wait().

## 23  What are the advantages and disadvantages of using signals for interprocess communication?
Signals are simple and fast for alerts, but they can’t send much information and may make the program harder to manage.

Advantages (Good Things)
 1️ Easy to use

Just send a signal — no big setup.

2️ Fast notification

The other process gets alerted immediately.

3️ Works even if processes don't share data

They don’t need shared memory, pipes, etc.

 4️ Good for alerts

Like:

process finished

process should stop or continue

Disadvantages (Bad Things)
1️ Can’t send much information

A signal only says “something happened”, nothing more.

 2️ Can interrupt the program

Makes the code harder because the signal can come anytime.

3️ Order is not guaranteed

Signals may arrive out of order.

4️ Not good for big communication

You can’t send large data, only a small notification.

## 24 Explain how a process handles a signal while it is in a sleep state
Signals wake sleeping processes because the kernel interrupts their sleep and delivers the signal.

What happens?

 ### The sleep is interrupted

The process wakes up immediately, even if the sleep time is not finished.

 ### The signal handler runs

If a custom handler is installed, that function executes.

 ### After handling:

Two possibilities:

 A. Sleep ends permanently
The system call returns early with an error (EINTR).

 B. Sleep restarts
If configured to restart (using flags like SA_RESTART), the sleep continues.

## 25 How does a process handle a signal while it is in a critical section?
Signal arrives → Stored as pending → Critical section finishes → Signal is handled.

1️ Signal arrives

The process is busy in a critical section.It cannot be interrupted. So the signal is not handled immediately.

2️ Signal becomes pending

The signal is stored in the pending signal list.It waits there.It is not lost.

3️ Process finishes the critical section

Now signals are unblocked.The process is safe to interrupt.

4️ Signal handler runs

The pending signal is delivered.The signal handler executes.

## 26.What are some of the challenges associated with signal handling in multi-threaded programs?
Hard to decide which thread should get the signal

 Signals may interrupt important work

 Can cause deadlocks

 Handlers must be very simple

 Hard to debug

 Each thread has different signal masks.
 
 ## 27.What is a race condition? Explain how it might occur in the context of signals?
Race condition:

A race condition happens when:

The main program is updating some data,

At the same time a signal arrives,

The signal handler also tries to use or change the same data,

The final result becomes wrong or corrupted because both run unexpectedly.
## 28 Discuss how a deadlock situation can be caused or resolved by signal handling?
### How signals CAUSE deadlock?

A signal can cause deadlock when:

The main program holds a lock (mutex/semaphore)

A signal arrives

The signal handler tries to take the same lock

Since the lock is already held → handler waits forever → deadlock

### How signals RESOLVE deadlock?

Signals like SIGALRM can break a deadlock by:

Interrupting a blocked system call (I/O, sem_wait)

The call returns with EINTR

The process can retry or exit → avoids infinite waiting.

## 29 How can you use signals to force a process to dump core?
Use SIGQUIT or SIGABRT to force a core dump

To make a process dump core, send one of these signals:

SIGABRT → always creates a core dump

SIGQUIT → also creates a core dump

## 30 What are the implications of using longjmp() and setjmp() in signal handlers?
Using setjmp/longjmp in signal handlers is dangerous because it breaks normal flow, skips clean-up, and can corrupt program state.

Implications of using setjmp()/longjmp() in signal handlers

## Program flow breaks suddenly
longjmp() jumps out of the handler suddenly → normal code does not finish properly.

## Locks stay locked
If the main program was holding a lock, longjmp() skips the unlock → causing deadlock.

## Not safe to use in handlers
longjmp() is not safe inside signal handlers → can make the program behave wrongly.

## 31 Difference between termination and suspending of a signa
### Termination

The process is completely stopped and removed from memory.

Example signals: SIGKILL, SIGTERM, SIGSEGV.

Process cannot continue again.

### Suspending

The process is paused (stopped) but not removed.

Example signal: SIGSTOP.

It can be continued later using SIGCONT.


Termination = process ends forever
Suspending = process pauses temporarily and can resume later.

## 32 How CPU access the device register?
CPU does NOT talk to the device directly. It accesses device registers through the device driver.

Steps:

Device driver knows the register address (memory-mapped I/O)

Driver uses read/write instructions →
*(volatile uint32_t *)address = value;

CPU then accesses that address and communicates with the device.

## 33 what is IRQ line?
IRQ = Interrupt Request Line

It is a wire used by a device to tell the CPU:

"Hey CPU, I need your attention!"

Each device has its own IRQ number.

When a device uses this line, the CPU stops its work and runs the ISR (Interrupt Service Routine).

IRQ line = hardware line that lets devices interrupt the CPU.

## 34 How do you find out unique value for each IRQ line?
You can find the IRQ number in:

 Device datasheet
 
 Hardware manual / board manual
 
 SoC reference manual
 
 Interrupt controller (GIC/PIC) documentation

These documents tell you the IRQ number assigned to each peripheral.

## 35 when interrupt occurs?
An interrupt occurs when:

A peripheral device needs CPU attention (e.g., keyboard key pressed, data ready, error).

A timer or internal event signals the CPU.

A software request asks the CPU to stop current work and handle something urgent.

Interrupt = CPU is alerted because something needs immediate attention.

## 36. when are exceptions when they occur?
When do exceptions occur?

Exceptions occur inside the CPU when the processor detects an unexpected or illegal condition during instruction execution, such as:

Division by zero

Invalid memory access (segmentation fault)

Arithmetic overflow

Invalid opcode

## 37 How does kernel informs to the parent that it(child) process is terminated?
When a child process terminates, the kernel sends a SIGCHLD signal to the parent.

The parent can handle it using:

A signal handler for SIGCHLD, or

wait() / waitpid() system call to get the child’s exit status.

## 38. Which member of PCB contains the information about the signals?
PCB members related to signals

Signal disposition table → stores what to do for each signal (default, ignore, or handler).

Pending signal info → stores signals that have arrived but not yet handled.

Signal mask → stores signals that are currently blocked.

## 39How can we replace SIGDEL with SIGING 40. (or) 41. How do you modify signal behaviour table/signal disposition
Use signal() or sigaction() to modify the signal disposition table for any signal.

signal(SIGINT, my_handler);   // Replace default SIGINT action

struct sigaction act;
act.sa_handler = my_handler;
sigemptyset(&act.sa_mask);
act.sa_flags = 0;
sigaction(SIGINT, &act, NULL);  // Replace SIGINT behaviour

## 42. why crash in program occurs?
Crash occurs when the program does something illegal.
Very simple reasons:

## Accessing invalid memory

Example: dereferencing NULL pointer, buffer overflow.

Dividing by zero

Causes SIGFPE.

## Using uninitialized pointers/variables

Points to garbage memory → crash.

Stack overflow

Too much recursion.

## Illegal instructions

Executing corrupted code.

## Race conditions

Two threads modifying memory → corruption → crash.


** Program crashes when it touches bad memory or performs illegal operations.

## 43 . How do you install signal handler in signal disposition table from user space?
User installs a signal handler using signal() or sigaction(). These update the signal disposition table in the PCB

## 44 How do you catch signal?
To catch a signal:

Write a handler function
```
void handler(int signo) {
    printf("Caught signal %d\n", signo);
}
```

Register it using signal() or sigaction()

This tells the kernel:

 When this signal comes, call my handler instead of default action

 You catch a signal by registering a handler using signal() or sigaction().

 ## 45. What does header file contains?
 A header file contains:

Function declarations

Macros

Structure definitions

Constant definitions

Type definitions.

<signal.h> contains signal numbers, signal handler function declarations, structures for signal handling, and macros like SIG_DFL and SIG_IGN.

## 46 How do you clear the content of sa_mask?
Use sigemptyset() to clear the sa_mask.

sigemptyset(&act.sa_mask);

It removes all signals from the mask → mask becomes empty.

## 47 Why signals are needed to be blocked?
Why signals need to be blocked?

Signals are blocked to prevent them from interrupting critical code.

 reasons:

To protect critical section → avoid corruption.

To avoid race conditions.

To delay signal handling until the program is in a safe state.

Block signals when you don’t want them to interrupt important work.

## 48. Signal no 2's corresponding bit is set to 1? what do you meant by it?
Each signal has a bit position in the pending signal bitmask or signal mask.

If the bit = 1 → the signal is pending or blocked.

If the bit = 0 → the signal is not pending / not blocked.

Signal 2’s bit is 1” means:

Signal number 2 (SIGINT) has arrived and is waiting to be handled (pending).

## 49.How can we see the blocking signal information in PC?
Use ps or /proc/<pid>/status to see blocked signal mask of a process.

1. ps command
   
ps -o pid,blocked -p <pid>


blocked column shows the signal mask in hex.

2. /proc/<pid>/status file

cat /proc/<pid>/status

Look for:

SigBlk → blocked signals

SigIgn → ignored signals

SigCgt → signals with custom handlers

SigPnd → pending signals

## 50. How do I get access to some information present in kernel space?
You CANNOT directly access kernel space from user space.Because the OS protects kernel memory for safety.

But you CAN get kernel information in these safe ways:

## Use System Calls

System calls are the only legal way for user programs to ask the kernel for information.

Examples:

getpid() → get process ID

kill() → send signal

read() / write() → access files

signal() / sigaction() → get/set signal info

## Use /proc File System (Linux only)

Kernel exposes information through files in /proc.

Examples:

/proc/cpuinfo → CPU info

/proc/meminfo → RAM info

/proc/<pid>/status → process info

/proc/<pid>/task/<tid>/status → thread info

/proc/<pid>/status has SigBlk, SigIgn, SigCgt (signal info).

## 3. Use sysfs (/sys)

For device and driver information.

Example:

/sys/class/net/ → network devices

/sys/block/ → block devices

##  4. Write Kernel Module (advanced)(This is done usually by driver developers.)

If you need custom access, you write a kernel module and expose data via:

/proc

/sys

IOCTL calls

## 51 During the execution of signal handler, other than default signal. Can you block additional signal?
Inside struct sigaction, the field sa_mask allows you to block extra signals while the handler is running.

By using sigaction we can block multiple signals using sigaddset
```
struct sigaction act;
act.sa_handler = myhandler;
sigemptyset(&act.sa_mask);          // clear mask
sigaddset(&act.sa_mask, SIGTERM);   // block SIGTERM
sigaddset(&act.sa_mask, SIGUSR1);   // block SIGUSR1
sigaction(SIGINT, &act, NULL);
```
When the SIGINT handler runs,

 SIGTERM and SIGUSR1 will be blocked automatically.
 
 They will execute only after the handler finishes.

 ## 52.Explain the scenario where signal is blocked?

 ## 53 From user space application can you access (Read/write) signal mask present in your PCB?
 Yes, indirectly.

sigprocmask() → block or unblock signals

pthread_sigmask() → block/unblock signals in threads

sigpending() → see pending signals.

## 54 Where is the process information present?
Process information is stored in the kernel, specifically in the Process Control Block (PCB).

PCB contains:

Process ID, state, priority

CPU registers, program counter

Memory management info

Signal info, open files, etc.

## 55 From userspace how do I access PCB information present in kernel space?
ou cannot access PCB directly from user space. ✅

You can only get information indirectly using system calls like:

getpid(), getppid() → process IDs

getpriority() → process priority

wait(), waitpid() → child status

sigprocmask(), sigpending() → signal info.

User space → system calls → kernel → PCB info

## 56  Can you create a proc virtual file system entry as user?

No , a regular user cannot create /proc entries.

Only the kernel or kernel modules can create entries in the /proc virtual file system.

User-space programs can read/write existing /proc files (if permissions allow), but cannot create new ones.

/proc entries = kernel-only; users can only access existing files.

## 57 Without sending a signal can you invoke mysighand?
Yes , you can invoke your signal handler like a normal function from your program.
```
void mysighandler(int signo){
    printf("Signal %d caught\n", signo);
}

int main() {
    mysighandler(SIGINT);  // Called directly without sending a signal
}
```
Signal handler can be called directly like any other function, no signal needed.

